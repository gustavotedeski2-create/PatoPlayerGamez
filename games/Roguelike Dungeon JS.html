<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Roguelike Dungeon JS</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #eee;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            background-color: #000;
            border: 4px solid #444;
            image-rendering: pixelated;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        #ui {
            width: 800px;
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 18px;
            font-weight: bold;
        }
        .stat-box {
            background: #333;
            padding: 5px 15px;
            border: 2px solid #555;
            border-radius: 4px;
        }
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #a00;
            padding: 40px;
            text-align: center;
            display: none;
        }
        button {
            background: #a00;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
            font-family: inherit;
        }
        button:hover { background: #c00; }
    </style>
</head>
<body>

    <div id="ui">
        <div class="stat-box" style="color:#f66">HP: <span id="hp-val">100</span></div>
        <div class="stat-box" style="color:#ff6">ATK: <span id="atk-val">10</span></div>
        <div class="stat-box" style="color:#6ff">Andar: <span id="level-val">1</span></div>
    </div>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div id="game-over">
        <h1 style="color:red">VOCÊ MORREU</h1>
        <p>Sua jornada acabou.</p>
        <p>Andar alcançado: <span id="final-level">1</span></p>
        <button onclick="restartGame()">Tentar Novamente</button>
    </div>

<script>
    // --- Configurações ---
    const TILE_SIZE = 32;
    const ROWS = 18; // 600px / 32 ~= 18
    const COLS = 25; // 800px / 32 = 25
    const MAX_ROOMS = 10;
    const MIN_ROOM_SIZE = 3;
    const MAX_ROOM_SIZE = 7;

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const uiHp = document.getElementById('hp-val');
    const uiAtk = document.getElementById('atk-val');
    const uiLevel = document.getElementById('level-val');
    const gameOverScreen = document.getElementById('game-over');
    const uiFinalLevel = document.getElementById('final-level');

    // --- Estado do Jogo ---
    let map = [];
    let player = {};
    let enemies = [];
    let items = [];
    let exit = {};
    let floorLevel = 1;
    let turnBlocked = false; // Sistema de turnos simples

    // Tipos de Tile
    const WALL = 1;
    const FLOOR = 0;

    // --- Input ---
    window.addEventListener('keydown', e => {
        if (player.hp <= 0) return;
        if (turnBlocked) return;

        let dx = 0;
        let dy = 0;

        if (e.key === 'ArrowUp' || e.key === 'w') dy = -1;
        if (e.key === 'ArrowDown' || e.key === 's') dy = 1;
        if (e.key === 'ArrowLeft' || e.key === 'a') dx = -1;
        if (e.key === 'ArrowRight' || e.key === 'd') dx = 1;

        if (dx !== 0 || dy !== 0) {
            playerTurn(dx, dy);
        }
    });

    // --- Lógica Principal ---

    function initGame() {
        floorLevel = 1;
        player = {
            x: 0,
            y: 0,
            hp: 100,
            maxHp: 100,
            atk: 10,
            color: '#fff'
        };
        startLevel();
    }

    function startLevel() {
        generateMap();
        spawnEntities();
        updateUI();
        draw();
        gameOverScreen.style.display = 'none';
        turnBlocked = false;
    }

    function generateMap() {
        // Preencher tudo com paredes
        map = [];
        for (let y = 0; y < ROWS; y++) {
            let row = [];
            for (let x = 0; x < COLS; x++) {
                row.push(WALL);
            }
            map.push(row);
        }

        const rooms = [];

        for (let i = 0; i < MAX_ROOMS; i++) {
            let w = Math.floor(Math.random() * (MAX_ROOM_SIZE - MIN_ROOM_SIZE + 1)) + MIN_ROOM_SIZE;
            let h = Math.floor(Math.random() * (MAX_ROOM_SIZE - MIN_ROOM_SIZE + 1)) + MIN_ROOM_SIZE;
            let x = Math.floor(Math.random() * (COLS - w - 2)) + 1;
            let y = Math.floor(Math.random() * (ROWS - h - 2)) + 1;

            let newRoom = { x, y, w, h, center: { x: Math.floor(x + w / 2), y: Math.floor(y + h / 2) } };

            // Checa sobreposição
            let failed = false;
            for (let other of rooms) {
                if (newRoom.x <= other.x + other.w && newRoom.x + newRoom.w >= other.x &&
                    newRoom.y <= other.y + other.h && newRoom.y + newRoom.h >= other.y) {
                    failed = true;
                    break;
                }
            }

            if (!failed) {
                createRoom(newRoom);
                if (rooms.length > 0) {
                    let prev = rooms[rooms.length - 1].center;
                    let curr = newRoom.center;
                    
                    // Corredores
                    if (Math.random() > 0.5) {
                        createHCorridor(prev.x, curr.x, prev.y);
                        createVCorridor(prev.y, curr.y, curr.x);
                    } else {
                        createVCorridor(prev.y, curr.y, prev.x);
                        createHCorridor(prev.x, curr.x, curr.y);
                    }
                }
                rooms.push(newRoom);
            }
        }
        return rooms;
    }

    function createRoom(room) {
        for (let y = room.y; y < room.y + room.h; y++) {
            for (let x = room.x; x < room.x + room.w; x++) {
                map[y][x] = FLOOR;
            }
        }
    }

    function createHCorridor(x1, x2, y) {
        for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
            map[y][x] = FLOOR;
        }
    }

    function createVCorridor(y1, y2, x) {
        for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
            map[y][x] = FLOOR;
        }
    }

    function spawnEntities() {
        enemies = [];
        items = [];
        
        // Encontrar tiles de chão livres
        let freeTiles = [];
        for(let y=0; y<ROWS; y++){
            for(let x=0; x<COLS; x++){
                if(map[y][x] === FLOOR) freeTiles.push({x, y});
            }
        }

        // Shuffle
        freeTiles.sort(() => Math.random() - 0.5);

        // Player no primeiro tile livre
        let startPos = freeTiles.pop();
        player.x = startPos.x;
        player.y = startPos.y;

        // Saída (Escada) no último tile (geralmente longe)
        let exitPos = freeTiles.shift(); // Pega do inicio (longe do pop) ou aleatório
        exit = { x: exitPos.x, y: exitPos.y };

        // Inimigos (baseado no andar)
        let enemyCount = 3 + floorLevel;
        for(let i=0; i<enemyCount; i++){
            if(freeTiles.length === 0) break;
            let pos = freeTiles.pop();
            enemies.push({
                x: pos.x, 
                y: pos.y, 
                hp: 20 + (floorLevel * 5), 
                atk: 5 + floorLevel
            });
        }

        // Itens
        let itemCount = 2;
        for(let i=0; i<itemCount; i++){
            if(freeTiles.length === 0) break;
            let pos = freeTiles.pop();
            // Tipo 0: Cura, Tipo 1: Força
            items.push({
                x: pos.x,
                y: pos.y,
                type: Math.random() > 0.5 ? 'heal' : 'str'
            });
        }
    }

    // --- Lógica de Turno ---

    function playerTurn(dx, dy) {
        const destX = player.x + dx;
        const destY = player.y + dy;

        // Checar Paredes
        if (map[destY][destX] === WALL) {
            // Efeito visual de bloqueio?
            return;
        }

        // Checar Inimigos (Combate)
        let targetEnemy = enemies.find(e => e.x === destX && e.y === destY);
        if (targetEnemy) {
            attackEnemy(targetEnemy);
            enemyTurn(); // Inimigos reagem
            draw();
            return;
        }

        // Movimento
        player.x = destX;
        player.y = destY;

        // Checar Itens
        let itemIndex = items.findIndex(i => i.x === player.x && i.y === player.y);
        if (itemIndex !== -1) {
            pickupItem(items[itemIndex]);
            items.splice(itemIndex, 1);
        }

        // Checar Saída
        if (player.x === exit.x && player.y === exit.y) {
            floorLevel++;
            startLevel(); // Novo andar
            return; 
        }

        enemyTurn();
        draw();
    }

    function attackEnemy(enemy) {
        // Jogador bate no inimigo
        enemy.hp -= player.atk;
        // Feedback visual simples (shake ou cor) poderia ir aqui
        
        if (enemy.hp <= 0) {
            // Matou
            enemies = enemies.filter(e => e !== enemy);
            // Pequena cura ao matar (opcional, estilo vampirismo)
        }
    }

    function pickupItem(item) {
        if (item.type === 'heal') {
            player.hp = Math.min(player.hp + 20, player.maxHp);
            log("Você pegou uma Poção de Vida!");
        } else if (item.type === 'str') {
            player.atk += 2; // Upgrade permanente para a run
            log("Você pegou um Upgrade de Força!");
        }
        updateUI();
    }

    function enemyTurn() {
        enemies.forEach(enemy => {
            if (player.hp <= 0) return;

            const dist = Math.abs(player.x - enemy.x) + Math.abs(player.y - enemy.y);
            
            // Se estiver adjacente, ataca
            if (dist === 1) {
                player.hp -= enemy.atk;
                updateUI();
                if (player.hp <= 0) doGameOver();
                return;
            }

            // Se estiver perto (raio de visão), persegue
            if (dist < 8) {
                let dx = 0, dy = 0;
                if (player.x > enemy.x) dx = 1;
                else if (player.x < enemy.x) dx = -1;
                else if (player.y > enemy.y) dy = 1;
                else if (player.y < enemy.y) dy = -1;

                // Tenta mover. Inimigos não batem em paredes nem em outros inimigos
                if (map[enemy.y + dy][enemy.x + dx] !== WALL) {
                    // Colisão simples com outros inimigos
                    let blocked = enemies.some(e => e !== enemy && e.x === enemy.x + dx && e.y === enemy.y + dy);
                    if (!blocked && !(player.x === enemy.x + dx && player.y === enemy.y + dy)) {
                         enemy.x += dx;
                         enemy.y += dy;
                    }
                }
            }
        });
    }

    function doGameOver() {
        turnBlocked = true;
        uiFinalLevel.innerText = floorLevel;
        gameOverScreen.style.display = 'block';
    }

    function restartGame() {
        initGame();
    }

    function updateUI() {
        uiHp.innerText = player.hp;
        uiAtk.innerText = player.atk;
        uiLevel.innerText = floorLevel;
    }

    function log(msg) {
        console.log(msg); // Pode ser expandido para um log na tela
    }

    // --- Renderização ---

    function draw() {
        // Limpar tela
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Desenhar Mapa
        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                if (map[y][x] === WALL) {
                    ctx.fillStyle = '#444';
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                } else {
                    ctx.fillStyle = '#222';
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    // Grid lines sutis
                    ctx.strokeStyle = '#2a2a2a';
                    ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }
        }

        // Desenhar Saída
        ctx.fillStyle = '#00f'; // Azul
        ctx.fillRect(exit.x * TILE_SIZE + 4, exit.y * TILE_SIZE + 4, TILE_SIZE - 8, TILE_SIZE - 8);

        // Desenhar Itens
        items.forEach(item => {
            if (item.type === 'heal') ctx.fillStyle = '#0f0'; // Verde
            else ctx.fillStyle = '#ff0'; // Amarelo
            
            ctx.beginPath();
            ctx.arc(item.x * TILE_SIZE + 16, item.y * TILE_SIZE + 16, 8, 0, Math.PI*2);
            ctx.fill();
        });

        // Desenhar Inimigos
        enemies.forEach(enemy => {
            ctx.fillStyle = '#a00';
            ctx.fillRect(enemy.x * TILE_SIZE + 2, enemy.y * TILE_SIZE + 2, TILE_SIZE - 4, TILE_SIZE - 4);
            
            // HP Bar do inimigo
            ctx.fillStyle = 'red';
            ctx.fillRect(enemy.x * TILE_SIZE, enemy.y * TILE_SIZE - 4, TILE_SIZE, 3);
            ctx.fillStyle = '#0f0';
            let hpPct = Math.max(0, enemy.hp / (20 + (floorLevel * 5)));
            ctx.fillRect(enemy.x * TILE_SIZE, enemy.y * TILE_SIZE - 4, TILE_SIZE * hpPct, 3);
        });

        // Desenhar Jogador
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(player.x * TILE_SIZE + 16, player.y * TILE_SIZE + 16, 12, 0, Math.PI * 2);
        ctx.fill();
    }

    // Iniciar
    initGame();

</script>
</body>
</html>